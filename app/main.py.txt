"""
FastAPI application entry point with Telegram webhook
Handles HTTP requests, webhook setup, and application lifecycle
"""
import logging
import asyncio
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from aiogram import types
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application
from aiohttp.web_app import Application
from telegram_bot import bot, dp
from config import WEBHOOK_URL, APP_HOST, APP_PORT

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Application lifespan manager
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager for startup and shutdown"""
    logger.info("🚀 Starting Telegram Voice Bot...")
    
    try:
        # Set webhook on startup
        webhook_info = await bot.get_webhook_info()
        
        if webhook_info.url != WEBHOOK_URL:
            logger.info(f"Setting webhook to: {WEBHOOK_URL}")
            await bot.set_webhook(
                url=WEBHOOK_URL,
                allowed_updates=["message", "callback_query"],
                drop_pending_updates=True
            )
            logger.info("✅ Webhook set successfully")
        else:
            logger.info("✅ Webhook already configured")
        
        # Get bot info
        bot_info = await bot.get_me()
        logger.info(f"🤖 Bot started: @{bot_info.username} ({bot_info.first_name})")
        
        yield
        
    except Exception as e:
        logger.error(f"❌ Startup error: {str(e)}")
        raise
    
    finally:
        # Cleanup on shutdown
        logger.info("🛑 Shutting down bot...")
        try:
            await bot.delete_webhook(drop_pending_updates=True)
            await bot.session.close()
            logger.info("✅ Bot shutdown complete")
        except Exception as e:
            logger.error(f"❌ Shutdown error: {str(e)}")

# Create FastAPI application
app = FastAPI(
    title="Telegram Voice Bot",
    description="AI-powered voice message transcription and analysis bot",
    version="1.0.0",
    lifespan=lifespan
)

# Root endpoint
@app.get("/")
async def root():
    """Health check endpoint"""
    try:
        bot_info = await bot.get_me()
        webhook_info = await bot.get_webhook_info()
        
        return {
            "status": "running",
            "bot": {
                "username": bot_info.username,
                "name": bot_info.first_name,
                "id": bot_info.id
            },
            "webhook": {
                "url": webhook_info.url,
                "has_custom_certificate": webhook_info.has_custom_certificate,
                "pending_updates": webhook_info.pending_update_count
            },
            "version": "1.0.0"
        }
    except Exception as e:
        logger.error(f"Health check failed: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={"status": "error", "error": str(e)}
        )

# Webhook endpoint for Telegram
@app.post("/webhook")
async def telegram_webhook(request: Request):
    """Handle incoming Telegram updates via webhook"""
    try:
        # Get request body
        body = await request.body()
        
        if not body:
            logger.warning("Received empty webhook body")
            raise HTTPException(status_code=400, detail="Empty request body")
        
        # Parse update
        try:
            data = await request.json()
            update = types.Update(**data)
        except Exception as e:
            logger.error(f"Failed to parse update: {str(e)}")
            raise HTTPException(status_code=400, detail="Invalid JSON or update format")
        
        # Process update
        await dp.feed_webhook_update(bot, update)
        
        return {"ok": True}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Webhook processing error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

# Health endpoint for monitoring
@app.get("/health")
async def health_check():
    """Simple health check for load balancers"""
    return {"status": "healthy", "service": "telegram-voice-bot"}

# Keep-alive endpoint for free hosting platforms
@app.get("/ping")
async def ping():
    """Ping endpoint to prevent sleeping on free hosting platforms"""
    return {"pong": True, "timestamp": "now"}

# Bot info endpoint
@app.get("/bot-info")
async def get_bot_info():
    """Get bot information"""
    try:
        bot_info = await bot.get_me()
        return {
            "id": bot_info.id,
            "username": bot_info.username,
            "first_name": bot_info.first_name,
            "can_join_groups": bot_info.can_join_groups,
            "can_read_all_group_messages": bot_info.can_read_all_group_messages,
            "supports_inline_queries": bot_info.supports_inline_queries
        }
    except Exception as e:
        logger.error(f"Failed to get bot info: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# Webhook info endpoint
@app.get("/webhook-info")
async def get_webhook_info():
    """Get current webhook information"""
    try:
        webhook_info = await bot.get_webhook_info()
        return {
            "url": webhook_info.url,
            "has_custom_certificate": webhook_info.has_custom_certificate,
            "pending_update_count": webhook_info.pending_update_count,
            "last_error_date": webhook_info.last_error_date,
            "last_error_message": webhook_info.last_error_message,
            "max_connections": webhook_info.max_connections,
            "allowed_updates": webhook_info.allowed_updates
        }
    except Exception as e:
        logger.error(f"Failed to get webhook info: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# Error handler
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Global exception handler"""
    logger.error(f"Unhandled exception: {str(exc)}")
    return JSONResponse(
        status_code=500,
        content={
            "detail": "Internal server error",
            "error": str(exc),
            "path": str(request.url)
        }
    )

# Add CORS headers for debugging (remove in production if not needed)
@app.middleware("http")
async def add_cors_header(request: Request, call_next):
    """Add CORS headers for development"""
    response = await call_next(request)
    response.headers["Access-Control-Allow-Origin"] = "*"
    response.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
    response.headers["Access-Control-Allow-Headers"] = "*"
    return response

# Development server function
async def start_development_server():
    """Start development server with polling (for local testing)"""
    logger.info("🔧 Starting development server with polling...")
    
    try:
        # Delete webhook for polling mode
        await bot.delete_webhook(drop_pending_updates=True)
        logger.info("✅ Webhook deleted for polling mode")
        
        # Start polling
        await dp.start_polling(bot)
        
    except KeyboardInterrupt:
        logger.info("🛑 Development server stopped")
    except Exception as e:
        logger.error(f"❌ Development server error: {str(e)}")
    finally:
        await bot.session.close()

# Main entry point
if __name__ == "__main__":
    import sys
    import uvicorn
    
    # Check if running in development mode
    if len(sys.argv) > 1 and sys.argv[1] == "dev":
        # Development mode with polling
        asyncio.run(start_development_server())
    else:
        # Production mode with webhook
        logger.info(f"🚀 Starting production server on {APP_HOST}:{APP_PORT}")
        uvicorn.run(
            "main:app",
            host=APP_HOST,
            port=APP_PORT,
            log_level="info",
            access_log=True
        )